using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace SignalR.Test.Generator;

[Generator(LanguageNames.CSharp)]
public class TypedSignalrClientGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var attributeContent = SourceText.From("""
                                                          // <auto-generated />
           
                                                          namespace SignalR.Client.Generator
                                                          {
                                                              [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
                                                              public sealed class TypedHubClientAttribute : Attribute
                                                              {
                                                                  public TypedHubClientAttribute(Type hubType)
                                                                  {
                                                                      HubType = hubType;
                                                                  }
                                                          
                                                                  public Type HubType { get; }
                                                              }
                                                          }
                                                          """
            , Encoding.UTF8);
        
        context.RegisterPostInitializationOutput(x =>
            x.AddSource("TypedHubClientAttribute.g.cs", attributeContent));
        
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            "SignalR.Client.Generator.TypedHubClientAttribute",
            predicate: static (node, _) => node.IsKind(SyntaxKind.ClassDeclaration),
            transform: static (ctx, _) => TransformContext(ctx)
        );

        context.RegisterSourceOutput(provider, static (productionContext, nodeInfo) =>
        {
            productionContext.AddSource($"{nodeInfo.Name}.g.cs",
                $$"""
                  // <auto-generated />
                  using Microsoft.AspNetCore.SignalR.Client;

                  namespace {{nodeInfo.Namespace}};

                  public partial class {{nodeInfo.Name}}
                  {
                  private readonly HubConnection hubConnection;
                  {{GenerateDelegates(nodeInfo.Name, nodeInfo.InterfaceType)}}
                  {{GenerateRequests(nodeInfo.HubRequestMethods)}}
                  }
                  """);
        });
    }

    private static string GenerateRequests(IMethodSymbol[] nodeInfoHubRequestMethods)
    {
        var methods = nodeInfoHubRequestMethods.Select(x =>
        {
            var parameters = string.Join(", ", x.Parameters.Select(p => $"{p.Type} {p.Name}"));
            var parametersInSend = string.Join(", ", x.Parameters.Select(p => p.Name));
            return $$"""
                     public async Task {{x.Name}}({{parameters}})
                     {
                         await hubConnection.SendAsync("{{x.Name}}", {{parametersInSend}});
                     }
                     """;
        });
        return string.Join("\n", methods);
    }

    private static string GenerateDelegates(string className, IMethodSymbol[] tupleInterfaceType)
    {
        var delegateAndCtor = GenerateDelegatesAndCtorBody(tupleInterfaceType);
        return $$"""
                 {{delegateAndCtor.eventAndDelegate}}
                  
                     public {{className}}(HubConnection hubConnection)
                     {
                         this.hubConnection = hubConnection;
                         {{delegateAndCtor.ctorBody}}
                     }
                  
                 """;
    }

    private static (string eventAndDelegate, string ctorBody) GenerateDelegatesAndCtorBody(
        IMethodSymbol[] tupleInterfaceType)
    {
        return tupleInterfaceType.Select(x =>
            {
                var types = string.Join(",", x.Parameters.Select(p => p.Type));
                var parametersInDelegate = string.Join(", ", x.Parameters.Select(p => $"{p.Type} {p.Name}"));
                var parametersInOn = string.Join(", ", x.Parameters.Select(p => p.Name));
                var action = $"({parametersInOn}) => {x.Name}Handler?.Invoke({parametersInOn})";
                return (
                    $"""
                         public event {x.Name}Delegate? {x.Name}Handler;
                         public delegate void {x.Name}Delegate({parametersInDelegate});

                     """,
                    $"hubConnection.On<{types}>(\"{x.Name}\", {action});\n\t\t");
            })
            .Aggregate((x, y) => (x.Item1 + y.Item1, x.Item2 + y.Item2));
    }

    private static (string Name, string Namespace, IMethodSymbol[] HubRequestMethods, IMethodSymbol[] InterfaceType) TransformContext(GeneratorAttributeSyntaxContext ctx)
    {
        var typeSymbol = (INamedTypeSymbol)ctx.Attributes
            .First(x => x.AttributeClass?.Name == "TypedHubClientAttribute")
            .ConstructorArguments
            .First().Value!;
        
        var hubRequestType = typeSymbol!
            .GetMembers()
            .Where(x => x.Kind == SymbolKind.Method &&
                        x.DeclaredAccessibility == Accessibility.Public & x.Name != ".ctor")
            .Select(x => (IMethodSymbol)x);
        var hubResponseType = typeSymbol.BaseType!
                    .TypeArguments[0]
                    .GetMembers()
                    .Where(x => x.Kind == SymbolKind.Method &&
                                x.DeclaredAccessibility == Accessibility.Public & x.Name != ".ctor")
                    .Select(x => (IMethodSymbol)x);
        return (ctx.TargetSymbol.Name, ctx.TargetSymbol.ContainingNamespace.ToString(), hubRequestType.ToArray(), hubResponseType.ToArray());
    }
}