using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace SignalR.Test.Generator;

[Generator(LanguageNames.CSharp)]
public class SignalRTestGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create Attribute SignalRTest
        var attributeContent = SourceText.From("""
                                               // <auto-generated />

                                               namespace SignalR.Test.Generator
                                               {
                                                   [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
                                                   public sealed class SignalRTestAttribute : Attribute
                                                   {
                                                       public SignalRTestAttribute(Type hubType)
                                                       {
                                                           HubType = hubType;
                                                       }
                                               
                                                       public Type HubType { get; }
                                                   }
                                                   
                                                   public record SignalREvent(string EventName, object[] EventArgs);
                                                   
                                                   public class SignalRTestException : Exception
                                                   {
                                                       public SignalRTestException(string message) : base(message)
                                                       {
                                                       }
                                                   }
                                               }
                                               """
            , Encoding.UTF8);
        context.RegisterPostInitializationOutput(x =>
            x.AddSource("SignalRTestCommon.g.cs", attributeContent));

        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            "SignalR.Test.Generator.SignalRTestAttribute",
            predicate: static (node, _) => node.IsKind(SyntaxKind.ClassDeclaration),
            transform: static (ctx, _) => TransformContext(ctx)
        );

        context.RegisterSourceOutput(provider, static (productionContext, nodeInfos) =>
        {
            var className = nodeInfos.Name;
            var responseContainerName = $"{nodeInfos.Name}ResponseContainer";
            var responseName = $"{nodeInfos.Name}Response";
            var requestName = $"{nodeInfos.Name}Request";
            productionContext.AddSource($"{nodeInfos.Name}.g.cs",
                $$"""
                  // <auto-generated />
                  using SignalR.Test.Generator;
                  using Microsoft.AspNetCore.SignalR.Client;
                  using System.Threading.Channels;

                  namespace {{nodeInfos.Namespace}};

                  public partial class {{className}}
                  {
                      private readonly HubConnection _hubConnection;
                      private readonly Channel<SignalREvent> _events = Channel.CreateUnbounded<SignalREvent>();
                      
                      public {{className}}(IHubConnectionBuilder connection)
                      {
                          _hubConnection = connection.Build();
                      }
                      
                      public async Task StartAsync(CancellationToken cancellationToken = default)
                      {
                          {{BuildRegisterEvents(nodeInfos.HubResponseMethods)}}
                          await _hubConnection.StartAsync(cancellationToken);
                      }
                      
                      public {{responseContainerName}} Events => new {{responseContainerName}}(_events);
                      public {{requestName}} Requests => new {{requestName}}(_hubConnection);
                  }
                  """);

            productionContext.AddSource($"{responseContainerName}.g.cs",
                $$"""
                  // <auto-generated />
                  using System.Threading.Channels;

                  namespace SignalR.Test.Generator;

                  public class {{responseContainerName}}
                  {
                      private readonly Channel<SignalREvent, SignalREvent> _events;
                      private SignalREvent _currentEvent = default!;
                    
                      public {{responseContainerName}}(Channel<SignalREvent, SignalREvent> events)
                      {
                          _events = events;
                      }
                    
                      public async Task<{{responseName}}> PopAsync(CancellationToken cancellationToken = default)
                      {
                          _currentEvent = await _events.Reader.ReadAsync(cancellationToken);
                          return new {{responseName}}(_currentEvent);
                      }
                  
                      public {{responseName}} Pop()
                      {
                          return PopAsync().Result;
                      }
                  }
                  """);

            productionContext.AddSource($"{responseName}.g.cs",
                $$"""
                  // <auto-generated />
                  namespace SignalR.Test.Generator;

                  public class {{responseName}}
                  {
                      private readonly SignalREvent _event;
                       
                      public {{responseName}}(SignalREvent @event)
                      {
                          _event = @event;
                      }
                       
                  {{BuildResponseMethods(nodeInfos.HubResponseMethods)}}
                  }
                  """);

            productionContext.AddSource($"{requestName}.g.cs",
                $$"""
                  // <auto-generated />
                  using Microsoft.AspNetCore.SignalR.Client;
                  
                  namespace SignalR.Test.Generator;

                  public class {{requestName}}
                  {
                      private readonly HubConnection _hubConnection;
                       
                      public {{requestName}}(HubConnection hubConnection)
                      {
                          _hubConnection = hubConnection;
                      }
                       
                  {{BuildRequestMethods(nodeInfos.HubRequestMethods)}}
                  }
                  """);
        });
    }

    private static string BuildRequestMethods(IEnumerable<IMethodSymbol> nodeInfosHubRequestMethods)
    {
        var methods = nodeInfosHubRequestMethods
            .Select(x =>
            {
                return $$"""
                         public async Task {{x.Name}}({{string.Join(", ", x.Parameters.Select(p => $"{p.Type} {p.Name}"))}}, CancellationToken cancellationToken = default)
                         {
                             await _hubConnection.SendAsync("{{x.Name}}", {{string.Join(", ", x.Parameters.Select(p => p.Name))}}, cancellationToken: cancellationToken);
                         }
                         """;
            });
        return string.Join("\n", methods);
    }

    private static string BuildResponseMethods(IEnumerable<IMethodSymbol> hubResponseMethods)
    {
        var methods = hubResponseMethods
            .Select(x =>
            {
                return $$"""
                         public void {{x.Name}}(Func<{{string.Join(", ", x.Parameters.Select(p => $"{p.Type}"))}}, bool> func)
                         {
                             if (_event.EventName != "{{x.Name}}")
                             {
                                 throw new SignalRTestException("Expected event '{x.Name}' but got " + _event.EventName);
                             }
                             if (!func({{string.Join(", ", x.Parameters.Select(p => $"({p.Type})_event.EventArgs[{p.Ordinal}]"))}}))
                             {
                                 throw new SignalRTestException("Assertion failed");
                             }
                         }
                         """;
            });
        return string.Join("\n", methods);
    }

    private static string BuildRegisterEvents(IEnumerable<IMethodSymbol> hubResponseMethods)
    {
        // filter public methods and not constructors
        var events = hubResponseMethods
            .Select(x =>
            {
                var types = string.Join(",", x.Parameters.Select(p => p.Type));
                var parametersInOn = string.Join(", ", x.Parameters.Select(p => p.Name));
                var action =
                    $"({parametersInOn}) => await _events.Writer.WriteAsync(new SignalREvent(\"{x.Name}\", new object[]{{ {parametersInOn} }}), cancellationToken)";
                return $"_hubConnection.On<{types}>(\"{x.Name}\", async {action});";
            });
        return string.Join("\n", events);
    }

    private static (string Name, string Namespace, IMethodSymbol[] HubRequestMethods, IMethodSymbol[] HubResponseMethods)
        TransformContext(
            GeneratorAttributeSyntaxContext ctx)
    {
        var typeSymbol = ctx.Attributes
            .First(x => x.AttributeClass?.Name == "SignalRTestAttribute")
            .ConstructorArguments[0].Value! as INamedTypeSymbol;
        var hubRequestType = typeSymbol!
            .GetMembers()
            .Where(x => x.Kind == SymbolKind.Method &&
                        x.DeclaredAccessibility == Accessibility.Public & x.Name != ".ctor")
            .Select(x => (IMethodSymbol)x);
        var hubResponseType = typeSymbol.BaseType!
            .TypeArguments[0]
            .GetMembers()
            .Where(x => x.Kind == SymbolKind.Method &&
                        x.DeclaredAccessibility == Accessibility.Public & x.Name != ".ctor")
            .Select(x => (IMethodSymbol)x);
        return (ctx.TargetSymbol.Name, ctx.TargetSymbol.ContainingNamespace.ToString(), hubRequestType.ToArray(), hubResponseType.ToArray());
    }
}